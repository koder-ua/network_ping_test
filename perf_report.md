## Тесты asyncio & Co.

### Что тестировалось

Asyncio в сравнении с другими способы обработки TCP соединений в питоне на предмет:

* Способности обрабатывать большие количества соединений >=10k
* Скорости и латентности на малых, средних и больших количествах соединений.

### Описание методики

Тестировалась пересылка коротких(64b) сообщений между
клиентом и сервером в режиме ping-pong в течении фиксированного времени (30s).
Сервер написан на С++ & epoll, исполняется в 3х потоках. Вся статистика
(сообщения, латентности, таймауты) ведется на сервере.

Клиент открывает слушающий сокет, открывает с сервером управляющее соединение
и передает настройки теста. Сервер открывает необходимое количество соединений
с клиентом и начинает пересылать сообщения. Сообщения не начинают пересылаться
пока все затребованные соединения не установлены (есть небольшая проблема с
поведением listen, ее влияние нивелируется дополнительным таймаутом).

По окончанию теста сервер передает клиенту статистику. Клиент замеряет использование
времени в пользовательском режиме и ядром на своей стороне (os.times).

Измерения проводились в двух вариантах - с локальным сервером и с сервером на другой машине, но
в одном сегменте локальной сети.

Все тесты запускались с привязкой питоновского процесса к одному ядру. Без привязки:

* Питоновские потоки становятся значительно медленнее из-за GIL и особенностей шедулинга [6];
* C++ потоки получили бы преймущество над однопоточным питоном.

Локальные тесты исполнялись по 7 раз, удаленные по 15.

Код тестов - [7].

Протестированные функции:

* asyncio - asyncio streams. Дефолтный способ использования asyncio [1], см. ниже.
* asyncio\_proto - asyncio на протоколах. Фактически аналог twisted protocols [2], см. ниже
* asyncio\_sock - asyncio с "сырыми" сокетами, используя ev\_loop.sock\_recv/ev\_loop.sock\_sendall, см. ниже.
* gevent - [3]
* selector - используя один поток и модуль selectors [4]. По умолчанию под линукс используется epoll
* thread - потоки, по одному потоку на каждого клиента
* uvloop,uvloop\_proto,uvloop\_sock - тот же код что и для asyncio,asyncio\_proto и asyncio\_sock,
    соответственно, но вместо asyncio.new\_event\_loop использовалось uvloop.new\_event\_loop
    библиотеки uvloop [5]
* cpp_epoll - c++ модуль с использованием epoll
* cpp_th - c++ модуль на потоках. По одному std::thread на каждый сокет.

#### Варианты asyncio API

Код всех примеров сокращен до минимального размера, сохраняющего общую логику.

asyncio streams (тест asyncio) - основной способ использования asyncio. yeild-based API.

````python
async def tcp_echo_client(reader, writer):
    while True:
        data = await reader.read(params.msize)
        if not data:
            break
        writer.write(data)
````

asyncio + raw sockets (тест asyncio_sock) - asyncio в комбинации с "сырыми" сокетами. yeild-based API.

````python
async def client(loop, sock):
    while True:
        data = await loop.sock_recv(sock, params.msize)
        if not data:
            break
        await loop.sock_sendall(sock, data)
````

asyncio protocols (тест asyncio_proto) - twisted-like API. Класс с виртуальными
методами, которые выхываются в ответ на события протокола.

````python
class EchoProtocol(asyncio.Protocol):
    def connection_made(self, transport):
        self.transport = transport

    def connection_lost(self, exc):
        self.transport = None

    def data_received(self, data):
        if not data:
            self.transport.close()
        else:
            self.transport.write(data)
````

#### Сервера:

* Ubuntu 14.04.1
* 3.19.0-25-generic #26~14.04.1-Ubuntu x86_64
* Python 3.5.1
* Intel(R) Xeon(R) CPU E3-1231 v3 @ 3.40GHz
* Управление энергопотреблением выключено, все ядра работали на 3.4Ghz
* 1Gb Full, Intel Corporation I350 Gigabit Network Connection (rev 01)
* uvloop 0.4.28.

#### Сеть:

iperf тесты сети


#### Исполнение тестов

Запуск сервера:

```
# ulimit -n 65536
# echo 1024 65535 | tee /proc/sys/net/ipv4/ip_local_port_range
# taskset -c 2,4,6 ./bin/server
```

Запуск клиента:

```
# ulimit -n 65536
# echo 1024 65535 | tee /proc/sys/net/ipv4/ip_local_port_range    
# taskset -c 0 python3.5 main.py ....
```

Использовались только пакеты по 64 байта. Использование больших по размеру пакетов
бессмысленно, посколько код обработки оперирует только указателями на буфер, а
накладные расходы на передачу данных между буфером и сокетом лежат на операционной
системе и одинаковы для всех вариантов. Также увеличение размеров сообщения приводит
к быстрому насыщению канала связи для нелокальных тестов, что скрывает различия между
тестами.


#### Особенности

Для тестов asyncio\_sock uvloop\_sock (uvloop<0.4.28) с сокетами  и локальным сервером
все соединения делятся на две группы - активные и стагнирующие. Активные постоянно
обслуживаются и обрабатывают основную массу сообщений (>95%) в то время как стагнирующие
крайне редко получали кванты времени и обрабатывали единичные сообщения. В итоге при 20k
соединений активны менее 100, что не позволяет корректно сравнить эти функции с другими.

Причина в этом участке кода (asyncio/selector\_events.py:321):

```python
def _sock_recv(self, fut, registered, sock, n):
    ...
    try:
        data = sock.recv(n)
    except (BlockingIOError, InterruptedError):
        ADD_THIS_SOCKET_TO_EPOLL
        CONTINUE_WITH_NEXT_SOCKET
    except Exception as exc:
        set exception to future
        CONTINUE_WITH_THIS_SOCKET
    else:
        set result to future
        CONTINUE_WITH_THIS_SOCKET
```

Если клиент высокоактивен, то data = sock.recv(n) успешно исполнится
и продолжится обработка текущего сокета.

Это так же поясняет почему для asyncio+socket получается такое низкое количество
вызовов epoll\_ctl. В uvloop==0.4.28 это поведение не проявляется.

Сам по себе этот код не является ошибкой и подобная проблемы врядли имеет возможно
возникнуть в реальности, поскольку даже разнесение сервера и клиента на разные машины
приводит к возникновению достаточно большого лага между отсылкой запроса и приходом
ответа. Но данная оптимизация сильно ускоряет вариант, когда данные из сокета
вычитываются порциями (например при разборе протокола, с длинной впереди сообщения).


#### Распределение нагрузки ядро/питон

Процент времени, используемый ядром для обслуживания tcp стека
(по выводу perf record):

```
uvloop, remote server = 35%
uvloop, local server  = 50%

asyncio, remote server = 20%
asyncio, local server  = 30%
```

При локальном тестировании сильно возрастает нагрузка на CPU из ядра,
поскольку небходимо обслуживать две стороны tcp стека. Так-же локально
исполняется сервер нагрузки. Это приводит к том, что локальные тесты
показывают меньшую скорость передачи пакетов.

Однако на небольшом количестве сокетов удаленный сервер медленее,
посколько время обработки всех сокетов оказывается меньше
пинга сети. Т.е. возникают промежутки времени, когда система простаивает,
не имея данных ни на одном сокете.


#### Максимальное количество соединений

Рассматриваемые результат ограниченны 60к соединений для тестов,
основанных на [e]poll и 30к соединений для тестов, основанных на потоках
(потоки см. следующий пункт).

Для IPv4 максимальное количество соединений между двумя IP адресами
по TCP протоколу ограничено количеством портов - 65534. Что-бы оперировать
бОльшим количеством соединений между двумя машинами можно присоединить
дополнительные IP адреса на сетевое устройство, и открыть по одному
серверному сокету на каждый адрес. См. также тут [8].


#### Максимальное количество потоков

Мне не удалось запустить более 30к С++ потоков. Код вылетает по исчерпанию ресурсов.

```
# echo 1048576 > /proc/sys/vm/max_map_count
# echo 2097152 > /proc/sys/kernel/threads-max
```

не помогает. Я предполагаю что нужно ограничить размеры стека для потоков,
но не Python ни C++11 не позволяют это сделать (в posix/boost можно ограничивать
размер стека, но я использовал std::thread).

Python ведет себя нестабильно при 10k+ потоков.


#### Отличия от реальных систем

* Основным отличием от реальных систем является почти полное отсутствие задержек в
протоколе. Сервер поддерживает таймауты на сокетах, но эти тесты я еще не довел
до конца.
* Можно было потюнить TCP стек
* ???


### Тесты скорости:

Сырые данные доступны тут [12]. 172.16.40.37 - удаленный сервер,
172.16.40.43 - локальный.

Сообщений в секунду ~ 2.5 * stddev (== 95% интервал). Удаленный сервер.

![](/images/remote_mps.png)


То же, но без cpp_epoll:
![](/images/remote_mps_no_cpp_epoll.png)

<pre>
+---------------+-------------+-------------+-------------+-------------+-------------+-------------+
|     Test      |     10      |     100     |     1k      |     10k     |     31k     |     60k     |
+===============+=============+=============+=============+=============+=============+=============+
|    asyncio    |   37k ~  6% |   42k ~  4% |   39k ~  8% |   25k ~  4% |   20k ~  6% |   18k ~  4% |
| asyncio_proto |   87k ~ 10% |  100k ~ 15% |   99k ~ 15% |   77k ~ 27% |  110k ~  6% |  110k ~  4% |
| asyncio_sock  |   22k ~  5% |   24k ~  3% |   22k ~  6% |   20k ~  4% |   18k ~  3% |   17k ~  4% |
|   cpp_epoll   |  150k ~ 14% |  600k ~  4% |  570k ~  4% |  310k ~  4% |  240k ~  4% |  290k ~  2% |
|    cpp_th     |  140k ~ 14% |  330k ~  3% |  250k ~  4% |  180k ~  4% |  140k ~  2% |     ---     |
|    gevent     |   84k ~  9% |   86k ~  5% |   73k ~  5% |   62k ~  6% |   65k ~  7% |   63k ~  6% |
|   selector    |  120k ~ 19% |  290k ~  5% |  280k ~  5% |  160k ~  7% |  170k ~  3% |  180k ~  4% |
|    thread     |  130k ~ 18% |  240k ~  3% |  170k ~  4% |  130k ~  9% |     ---     |     ---     |
|    uvloop     |   99k ~  4% |  120k ~  5% |   99k ~  6% |   49k ~  2% |   36k ~  4% |   34k ~  6% |
| uvloop_proto  |  140k ~ 19% |  360k ~  6% |  350k ~  4% |  150k ~  7% |  170k ~  4% |  190k ~  5% |
|  uvloop_sock  |  100k ~ 10% |  150k ~  5% |  140k ~  7% |   76k ~  6% |   75k ~  3% |   75k ~  4% |
+---------------+-------------+-------------+-------------+-------------+-------------+-------------+
</pre>


Относительные скорости:

<pre>
+---------------+----+-----+----+-----+-----+-----+
|     Test      | 10 | 100 | 1k | 10k | 31k | 60k |
+===============+====+=====+====+=====+=====+=====+
|    asyncio    |  2 |  2  |  2 |  1  |  1  |  1  |
| asyncio_proto |  5 |  6  |  6 |  4  |  6  |  6  |
| asyncio_sock  |  1 |  1  |  1 |  1  |  1  |  1  |
|   cpp_epoll   |  9 | 34  | 32 | 18  | 14  | 17  |
|    cpp_th     |  8 | 19  | 14 | 10  |  8  | --- |
|    gevent     |  5 |  5  |  4 |  3  |  4  |  4  |
|   selector    |  7 | 17  | 16 |  9  | 10  | 10  |
|    thread     |  7 | 14  | 10 |  7  | --- | --- |
|    uvloop     |  6 |  7  |  6 |  3  |  2  |  2  |
| uvloop_proto  |  8 | 21  | 20 |  9  | 10  | 11  |
|  uvloop_sock  |  6 |  9  |  8 |  4  |  4  |  4  |
+---------------+----+-----+----+-----+-----+-----+
</pre>

Локальный сервер. asyncio_sock для >10 сокетов исключены, см. раздел "Особенности".

![](/images/local_mps.png)

<pre>
+---------------+-------------+-------------+-------------+-------------+-------------+-------------+
|     Test      |     10      |     100     |     1k      |     10k     |     30k     |     60k     |
+===============+=============+=============+=============+=============+=============+=============+
|    asyncio    |   33k ~ 22% |   38k ~ 13% |   34k ~  9% |   26k ~  9% |   20k ~  5% |   19k ~  6% |
| asyncio_proto |   76k ~ 39% |   85k ~ 20% |   83k ~ 14% |   86k ~ 34% |  100k ~  2% |   96k ~  1% |
| asyncio_sock  |   78k ~ 51% |      ---    |      ---    |     ---     |      ---    |     ---     |
|   cpp_epoll   |  420k ~  4% |  450k ~ 12% |  360k ~ 29% |  240k ~  2% |  220k ~  1% |  230k ~  4% |
|    cpp_th     |  290k ~ 11% |  280k ~ 12% |  170k ~  6% |  130k ~ 17% |  140k ~ 25% |     ---     |
|    gevent     |   64k ~ 39% |   73k ~ 21% |   62k ~ 11% |   65k ~  4% |   60k ~ 10% |   57k ~  9% |
|   selector    |  220k ~ 11% |  230k ~ 22% |  210k ~  7% |  170k ~  3% |  160k ~  2% |  140k ~  7% |
|    thread     |  220k ~  1% |  200k ~  9% |  120k ~ 10% |   78k ~ 83% |     ---     |     ---     |
|    uvloop     |  100k ~ 13% |  110k ~ 14% |   83k ~  9% |   47k ~  3% |   38k ~  3% |   33k ~ 10% |
| uvloop_proto  |  260k ~ 24% |  300k ~ 19% |  230k ~ 16% |  130k ~  8% |  160k ~  2% |  150k ~  3% |
|  uvloop_sock  |  120k ~ 14% |  120k ~ 13% |  110k ~ 12% |   76k ~  2% |   73k ~  5% |   71k ~  5% |
+---------------+-------------+-------------+-------------+-------------+-------------+-------------+
</pre>

Относительные скорости:

<pre>
+---------------+----+-----+----+-----+-----+-----+
|     Test      | 10 | 100 | 1k | 10k | 30k | 60k |
+===============+====+=====+====+=====+=====+=====+
|    asyncio    |  2 |  2  |  2 |  1  |  1  |  1  |
| asyncio_proto |  4 |  4  |  4 |  4  |  5  |  5  |
| asyncio_sock  |  4 |  4  |  3 |  4  |  5  |  5  |
|   cpp_epoll   | 22 | 24  | 19 | 13  | 11  | 12  |
|    cpp_th     | 15 | 15  |  9 |  7  |  8  | --- |
|    gevent     |  3 |  4  |  3 |  3  |  3  |  3  |
|   selector    | 11 | 12  | 11 |  9  |  8  |  8  |
|    thread     | 11 | 11  |  7 |  4  | --- | --- |
|    uvloop     |  5 |  6  |  4 |  2  |  2  |  2  |
| uvloop_proto  | 14 | 16  | 12 |  7  |  8  |  8  |
|  uvloop_sock  |  7 |  7  |  6 |  4  |  4  |  4  |
+---------------+----+-----+----+-----+-----+-----+
</pre>

#### Обсуждение

Общее распределение по убыванию скоростей примерно такое:

1. cpp\_epoll
2.
3. uvloop\_proto, selector
4. cpp\_th
5. thread
6. uvloop, uvloop\_sock, asyncio\_proto
7. gevent
8. asyncio
9. asyncio_sock

#### Странности:

Возрастание скорости некоторых тестов(cpp\_epoll) при переходе от 30k к 60k,
selector,uvloop_proto с 10k до 60k. Поведение хорошо воспроизводится.

![](/images/remote_10k_60k_issue.png)

![](/images/remote_cppepoll_10k_15k_issue.png)

Выводы по скорости:

* asyncio заметно медленее других систем
* И asyncio и uvloop тратят больше времени на накладные расходы, чем на реальную работу
  (за исключением uvloop_proto, но о нем ниже)
* uvloop во всех вариантах и режимах в 2.5-3 раза быстрее, чем asyncio,
  при (наверное) полной совместимости, однако все равно накладные расходы высоки
* uvloop_proto показывает очень высокие скорости (~1.5 медленнее С++) за счет
  избавления от практически всех накладных расходов, связанных с Future/yield.
* По мере роста количества соединений скорости у всех более-менее быстрых вариантов проседают
* Скорости вариантов на потоках и asyncio/uvloop падают быстрее всего
* Даже на 20k соединений потоки все еще в разы быстрее и asyncio/uvloop
* gevent весьма медленный
* asyncio/uvloop на потоках устанавливают соединения сильно медленее других функций
* 100 потоков быстрее 10 по описаным в разделе 'Распределение нагрузки ядро/питон' причинам
* Тесты на локальной машине показали довольно высокий разброс

Несмотря на то, что потоки показывают неплохую (по меркам питона) производительность
под нагрузками у них есть много минусов: сильный разброс латентности, сложно
контролировать, мониторить и отлаживать систему, etc.

Также иногда тест с питон потоками просто прекращал исполняться
и зависал, съедая 100% процессора.


#### Латентность

Латентность 95й персентиль (удаленный сервер):

![](/images/remote_lat95.png)

<pre>
+---------------+--------+--------+--------+--------+--------+--------+--------+--------+--------+                                                                                                                                                                                                                   |     Test      |   10   |   32   |  100   |  316   |   1k   |   3k   |  10k   |  31k   |  60k   |                                                                                                                                                                                                                   +===============+========+========+========+========+========+========+========+========+========+                                                                                                                                                                                                                   |    asyncio    | 222 us | 722 us | 2 ms   |  7 ms  | 24 ms  |  93 ms | 352 ms | 991 ms |  >1s   |                                                                                                                                                                                                                   | asyncio_proto |  79 us | 171 us | 917 us |  2 ms  |  9 ms  |  34 ms |  98 ms | 144 ms | 279 ms |                                                                                                                                                                                                                   | asyncio_sock  | 402 us | 1 ms   | 3 ms   | 11 ms  | 42 ms  | 134 ms | 449 ms |  >1s   |  >1s   |                                                                                                                                                                                                                   |   cpp_epoll   |  51 us |  35 us | 113 us | 272 us | 799 us |   6 ms |  18 ms |  34 ms |  74 ms |                                                                                                                                                                                                                   |    cpp_th     |  51 us |  37 us | 228 us | 631 us |  2 ms  |  11 ms |  45 ms | 109 ms |  ---   |                                                                                                                                                                                                                   |    gevent     |  67 us | 258 us | 993 us |  3 ms  | 12 ms  |  43 ms | 133 ms | 198 ms | 433 ms |                                                                                                                                                                                                                   |   selector    |  53 us |  61 us | 223 us | 761 us |  2 ms  |  11 ms |  44 ms |  92 ms | 163 ms |                                                                                                                                                                                                                   |    thread     |  50 us |  46 us | 319 us | 917 us |  3 ms  |  13 ms |  50 ms |  ---   |  ---   |                                                                                                                                                                                                                   |    uvloop     |  68 us | 177 us | 673 us |  1 ms  |  5 ms  |  18 ms | 183 ms | 542 ms |  >1s   |                                                                                                                                                                                                                   | uvloop_proto  |  52 us |  40 us | 169 us | 443 us |  1 ms  |  13 ms |  51 ms | 141 ms | 199 ms |                                                                                                                                                                                                                   |  uvloop_sock  |  54 us |  84 us | 582 us |  1 ms  |  5 ms  |  11 ms |  76 ms | 167 ms | 521 ms |                                                                                                                                                                                                         +---------------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
</pre>


Латентность медианная (удаленный сервер):

![](/images/remote_lat50.png)

<pre>
+---------------+--------+--------+--------+--------+--------+--------+--------+--------+--------+                                                                                                                                                                                                                   |     Test      |   10   |   32   |  100   |  316   |   1k   |   3k   |  10k   |  31k   |  60k   |                                                                                                                                                                                                                   +===============+========+========+========+========+========+========+========+========+========+                                                                                                                                                                                                                   |    asyncio    | 203 us | 713 us | 2 ms   |  6 ms  | 24 ms  |  93 ms | 323 ms | 983 ms |  >1s   |                                                                                                                                                                                                                   | asyncio_proto |  64 us | 167 us | 835 us |  2 ms  |  9 ms  |  29 ms |  76 ms | 139 ms | 269 ms |                                                                                                                                                                                                                   | asyncio_sock  | 396 us | 1 ms   | 3 ms   | 11 ms  | 40 ms  | 134 ms | 442 ms |  >1s   |  >1s   |                                                                                                                                                                                                                   |   cpp_epoll   |  39 us |  34 us |  99 us | 250 us | 729 us |   4 ms |  15 ms |  30 ms |  64 ms |                                                                                                                                                                                                                   |    cpp_th     |  39 us |  36 us | 166 us | 588 us |  2 ms  |  11 ms |  39 ms | 101 ms |  ---   |                                                                                                                                                                                                                   |    gevent     |  55 us | 252 us | 989 us |  3 ms  | 12 ms  |  38 ms | 110 ms | 193 ms | 324 ms |                                                                                                                                                                                                                   |   selector    |  47 us |  49 us | 165 us | 694 us |  2 ms  |   9 ms |  35 ms |  84 ms | 154 ms |                                                                                                                                                                                                                   |    thread     |  45 us |  45 us | 239 us | 895 us |  3 ms  |  10 ms |  32 ms |  ---   |  ---   |                                                                                                                                                                                                                   |    uvloop     |  58 us | 169 us | 647 us |  1 ms  |  5 ms  |  15 ms | 158 ms | 540 ms |  >1s   |                                                                                                                                                                                                                   | uvloop_proto  |  43 us |  40 us | 156 us | 405 us |  1 ms  |  11 ms |  45 ms | 133 ms | 176 ms |                                                                                                                                                                                                                   |  uvloop_sock  |  53 us |  78 us | 467 us |  1 ms  |  5 ms  |  11 ms |  67 ms | 165 ms | 503 ms |                                                                                                                                                                                                                   +---------------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
</pre>

Латентность согласуется с mps. В целом фунции, основанные на epoll/poll
циклах показывают меньший разброс латентности, чем основанные на потоках,
но отличие невелико.


#### Совершаемые системные вызовы

Все измерения проводились с помошью 'sudo perf stat -e '\*' ....' на 100 соединениях.

Для тестов asyncio, asyncio_sock, uvloop, uvloop_sock, gevent время
затрачиваемое на системные вызовы в 2-3 раза меньше, чем время работы
внутри библиотеки, поэтому состав вызовов для них играет меньшую роль в
производительности, но все равно помогает понять что внутри происходит.

тип_теста = количество вызововна один пинг

```
thread(no affinity) = sendto + recvfrom + 15 * futex
Основную часть времени система мучала GIL

thread(affinity) = sendto + recvfrom + 0.01 * futex
selector = sendto + recvfrom + 0.01 * epoll_wait

asyncio = sendto + recvfrom + mremap + munmap + mmap + 0.02 * epoll_wait
    Откуда берутся лишние обращения к mXXmap мне не понятно

asyncio_proto = sendto + recvfrom + mremap + munmap + mmap + 0.01 * epoll_wait
    Те же странные mXXmap, что и в asyncio

asyncio_sock(local) = sendto + recvfrom + 0.04 * epoll_ctl
    asyncio_sock должна делать 2 вызова epoll_ctl на каждый
    recvfrom, но из-за описанной выше опитимизации этого не происходит.

asyncio_sock(remote) = 2 * epoll_ctl + sendto + recvfrom + 0.01 * epoll_wait

uvloop = read + write + 0.01 * epoll_wait
uvloop_sock = 2 * epoll_ctl + sendto + recvfrom + 0.01 * epoll_wait
uvloop_proto = read + write + 0.01 * epoll_wait
cpp_th = recvfrom + write
cpp_poll = recvfrom + write + 0.01 * poll
cpp_epoll = recvfrom + write + 0.01 * epoll_wait
gevent = 2 * recvfrom + sendto + 0.01 * epoll_wait
```

#### Доля времени, проведенные в user mode во время теста (округлено до 5-10%):

Значения для других количеств соединений отличаются от этих очень слабо (в пределах погрешности).

<pre>
+---------------+----+
|     Test      | 1k |
+===============+====+
|       asyncio | 90 |
| asyncio_proto | 50 |
|  asyncio_sock | 90 |
|     cpp_epoll |  5 |
|      cpp_poll |  5 |
|        cpp_th |  5 |
|        gevent | 80 |
|      selector | 60 |
|        thread | 30 |
|        uvloop | 80 |
|  uvloop_proto | 40 |
|   uvloop_sock | 70 |
+---------------+----+
</pre>


### Общие выводы

* asyncio *очень медленный*. uvloop делает его просто медленным
* asyncio разрабатывался с целью быть единым API для обработки различных асинхронных источников данных,
и с этой задачей он справляется хорошо
* uvloop\_proto весьма быстрый, но его API - это классические функции обратного вызова,
неудобные в случае ad-hoc взаимодействия
* потоки быстрее, но имеют свои проблемы
* 'await' API еще очень далеко до с++/java/go.


#### Полезные ссылки

* Asyncio build in 45m - https://www.youtube.com/watch?v=MCs5OvhV9S
* Concurrency is not parallelism - https://blog.golang.org/concurrency-is-not-parallelism
* Доклад о тестах производительности - https://www.youtube.com/watch?v=zWxSZcpeS8Q
* С10K problem - http://www.kegel.com/c10k.html
* C10M problem - http://c10m.robertgraham.com/p/manifesto.html
* How far epoll can push concurrent socket connection - http://shenfeng.me/how-far-epoll-can-push-concurrent-socket-connection.html
* Акторы в скале - [9], [10], [11]
* Кусок эппопеи с шедулерами в Go - https://morsmachine.dk/go-scheduler
* Twisted & asyncio - https://glyph.twistedmatrix.com/2014/05/the-report-of-our-death.html
* Curio библиотека для асинхронного IO от David Beazley - https://github.com/dabeaz/curio

[1]: https://docs.python.org/3/library/asyncio-stream.html#tcp-echo-client-using-streams
[2]: https://docs.python.org/3/library/asyncio-protocol.html#tcp-echo-client-protocol
[3]: http://www.gevent.org/
[4]: https://docs.python.org/3/library/selectors.html
[5]: https://github.com/MagicStack/uvloop
[6]: https://www.mirantis.com/blog/improve-performance-python-programs-restricting-single-cpu/
[7]: https://github.com/koder-ua/network_ping_test
[8]: https://mrotaru.wordpress.com/2013/10/10/scaling-to-12-million-concurrent-connections-how-migratorydata-did-it/
[9]: http://danielwestheide.com/blog/2013/02/27/the-neophytes-guide-to-scala-part-14-the-actor-approach-to-concurrency.html
[10]: http://danielwestheide.com/blog/2013/03/20/the-neophytes-guide-to-scala-part-15-dealing-with-failure-in-actor-systems.html
[11]: http://doc.akka.io/docs/akka/snapshot/scala/actors.html
[12]: /results/unified_test_results.yaml
